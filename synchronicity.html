
// ===== chips =====
function buildChips(basesInfo, segs){
  const chipHtml = [];
  basesInfo.forEach(({base, master, ov}, idx) => {
    const entry = mapDigitToEntry(base);
    const majors = entry.majors || entry.Majors || [];
    const signs  = unique([...(entry.signs||entry.Signs||[]), ...(ov && ov.signs || [])]);
    const minors = minorsForBase(base);
    chipHtml.push(`<div class="chip">Seg ${idx+1}: ${segs[idx]} → ${master? master+'→':''}${base} · ${signs.join('/')} · Majors: ${(majors.length?majors.join(', '):'—')} · Minors: ${minors.join(', ')}</div>`);
  });
  return chipHtml.join('');
}

// ===== full reading builder =====
function buildReadingHTML(num, segs, basesInfo, finalBase){
  const parts = [];
  const anchorTitle = {
    1:"Clean Beginnings",2:"Living Balance",3:"True Expression",4:"Good Structure",
    5:"Gentle Change",6:"Caring Harmony",7:"Quiet Insight",8:"Calm Strength",9:"Clean Completion"
  }[finalBase] || "Anchor";

  parts.push(`<h2>${num} — ${anchorTitle} <span class="badge">${VERSION}</span></h2>`);
  parts.push(`<p>We split ${num} into ${segs.join(', ')}. Adding the bases resolves to ${finalBase}.</p>`);

  basesInfo.forEach((info, i)=>{
    const entry = mapDigitToEntry(info.base);
    const majors = entry.majors || entry.Majors || [];
    const signs  = unique([...(entry.signs||entry.Signs||[]), ...(info.ov && info.ov.signs || [])]);
    const minors = minorsForBase(info.base);
    parts.push(`<h3>Segment ${i+1} — ${info.master? 'Master '+info.master+' → ':''}${info.base}</h3>`);
    parts.push(ultraSegmentHTML(i+1, segs[i], info.base, majors, minors, signs, info.master, 'rich'));
  });

  // Expanded categories — each >=400 words
  parts.push(`<h3>If the question is Love</h3>${catLong(finalBase, 'love')}`);
  parts.push(`<h3>If the question is Work/Vocation</h3>${catLong(finalBase, 'work')}`);
  parts.push(`<h3>If the question is Confusion</h3>${catLong(finalBase, 'confusion')}`);
  parts.push(`<h3>If the question is Family</h3>${catLong(finalBase, 'family')}`);
  parts.push(`<h3>If the question is Frustration</h3>${catLong(finalBase, 'frustration')}`);

  parts.push(`<p>— Spirit Guide App</p>`);
  return parts.join('\n');
}

// ===== UI actions =====
function analyze(){
  const raw = $('num').value.trim();
  if(!raw){ alert('Enter a number.'); return; }

  const segs = splitPairsLeft(raw);
  const basesInfo = segs.map(s => segmentBase(s));
  const bases = basesInfo.map(x => x.base);
  const finalBase = reduceDigit(bases.reduce((a,b)=>a+b,0));

  $('resultCard').style.display = 'block';
  $('segments').textContent = segs.join(', ');
  $('bases').textContent = basesInfo.map(x => (x.master? x.master+'→':'') + x.base).join(', ');
  $('finalBase').textContent = String(finalBase);
  $('chips').innerHTML = buildChips(basesInfo, segs);

  const html = buildReadingHTML(raw, segs, basesInfo, finalBase);
  $('reading').innerHTML = html;

  $('status').textContent = 'Done';
  setTimeout(()=> $('status').textContent='', 2000);
}

function copyReading(){ 
  const txt = getSpeechText(($('reading').innerHTML||'').trim());
  navigator.clipboard.writeText(txt + '\n— Spirit Guide App').then(()=> alert('Copied reading (speech‑friendly)'));
}
function copyReadingHtml(){
  const html = $('reading').innerHTML;
  const blob = new Blob([html], {type:'text/html'});
  const reader = new FileReader();
  reader.onload = function(){ navigator.clipboard.writeText(reader.result).then(()=> alert('Copied HTML')); };
  reader.readAsText(blob);
}
$('analyzeBtn').onclick = analyze;
$('copyBtn').onclick = copyReading;
$('copyHtmlBtn').onclick = copyReadingHtml;

// ===== Narrator (Google‑only) + speech sanitizer + robust chunked queue =====
const STORAGE = { name:'sg_voice_name', lang:'sg_voice_lang', force:'sg_voice_force_en', rate:'sg_voice_rate', pitch:'sg_voice_pitch' };
const prefer = ["Google UK English Female","Google UK English Male","Google US English","Google US English Female","Google US English Male"];
let voices = [];
let speakQueue = [];
let speaking = false;

function isGoogle(v){ return /google/i.test(v.name||''); }
function englishOnly(v){ return $('forceEnglish').checked ? /^en[-_]/i.test(v.lang||'') : true; }

function waitForVoices(){
  return new Promise(resolve => {
    const list = window.speechSynthesis.getVoices();
    if (list && list.length){ resolve(list); return; }
    window.speechSynthesis.onvoiceschanged = () => resolve(window.speechSynthesis.getVoices());
    setTimeout(()=> resolve(window.speechSynthesis.getVoices()||[]), 800);
  });
}

async function populateVoices(){
  const list = await waitForVoices();
  voices = (list||[]).filter(v => isGoogle(v) && englishOnly(v));
  const sel = $('voiceSelect'); sel.innerHTML='';
  voices.forEach(v=>{ const opt=document.createElement('option'); opt.value=v.name+'::'+v.lang; opt.textContent=`${v.name} (${v.lang})`; sel.appendChild(opt); });

  const savedName = localStorage.getItem(STORAGE.name), savedLang = localStorage.getItem(STORAGE.lang);
  if(savedName && savedLang){
    const idx = Array.from(sel.options).findIndex(o => o.value === (savedName+'::'+savedLang));
    if(idx>=0){ sel.selectedIndex=idx; } else { sel.selectedIndex=0; }
  } else {
    let picked=false;
    for(const p of prefer){
      const idx = Array.from(sel.options).findIndex(o => o.textContent.includes(p));
      if(idx>=0){ sel.selectedIndex=idx; picked=true; break; }
    }
    if(!picked && sel.options.length) sel.selectedIndex=0;
  }
}

function currentVoice(){
  const sel = $('voiceSelect'); if(!sel || sel.selectedIndex<0) return null;
  const [name, lang] = sel.value.split('::');
  return (window.speechSynthesis.getVoices()||[]).find(v => v.name===name && v.lang===lang) || null;
}
function savePrefs(){
  const sel = $('voiceSelect'); const [name, lang] = (sel.value||'::').split('::');
  localStorage.setItem(STORAGE.name, name||''); localStorage.setItem(STORAGE.lang, lang||'');
  localStorage.setItem(STORAGE.force, $('forceEnglish').checked ? '1':'0');
  localStorage.setItem(STORAGE.rate, String($('rate').value)); localStorage.setItem(STORAGE.pitch, String($('pitch').value));
}
function loadPrefs(){
  $('forceEnglish').checked = localStorage.getItem(STORAGE.force) === '1';
  const r = parseFloat(localStorage.getItem(STORAGE.rate)); if(!isNaN(r)) $('rate').value = r;
  const p = parseFloat(localStorage.getItem(STORAGE.pitch)); if(!isNaN(p)) $('pitch').value = p;
}
function decodeEntities(html){
  const txt = document.createElement('textarea'); txt.innerHTML = html; return txt.value;
}
function getSpeechText(html){
  let text = decodeEntities(html);
  text = text.replace(/<script[\s\S]*?<\/script>/gi,' ')
             .replace(/<style[\s\S]*?<\/style>/gi,' ')
             .replace(/<[^>]+>/g,' ');
  text = text.replace(/→/g,' to ').replace(/•/g,', ').replace(/[#*_`~^]/g,' ').replace(/\s{2,}/g,' ').trim();
  return text;
}
function chunkText(text, maxLen=220){
  const sentences = text.split(/(?<=[\.\!\?])\s+/);
  const chunks = [];
  let buf = '';
  sentences.forEach(s=>{
    if ((buf + ' ' + s).trim().length > maxLen){
      if (buf) chunks.push(buf.trim());
      if (s.length > maxLen){
        for (let i=0;i<s.length;i+=maxLen){ chunks.push(s.slice(i,i+maxLen)); }
        buf = '';
      } else {
        buf = s;
      }
    } else {
      buf = (buf? buf+' ' : '') + s;
    }
  });
  if (buf) chunks.push(buf.trim());
  return chunks;
}
async function speakQueueStart(text){
  if(!('speechSynthesis' in window)) return alert('Speech not supported here.');
  window.speechSynthesis.cancel();
  speakQueue = []; speaking = false;
  const cleaned = getSpeechText(text||$('reading').innerHTML||'');
  if(!cleaned){ alert('Nothing to read yet. Tap Analyze first.'); return; }
  speakQueue = chunkText("Reflective guidance only. " + cleaned, 220);

  const v = currentVoice();
  const rate = parseFloat($('rate').value||'1'); const pitch = parseFloat($('pitch').value||'1');

  await new Promise(r => setTimeout(r, 160)); // post-cancel delay (many browsers need this)
  function next(){
    if (!speakQueue.length){
      speaking=false; $('status').textContent='Narration finished';
      setTimeout(()=> $('status').textContent='',1500);
      return;
    }
    const u = new SpeechSynthesisUtterance(speakQueue.shift());
    if (v) u.voice = v; u.rate = rate; u.pitch = pitch; u.volume = 1.0;
    u.onstart = ()=> { $('status').textContent='Speaking…'; };
    u.onend = ()=> next();
    u.onerror = ()=> next();
    speaking = true;
    try { window.speechSynthesis.speak(u); }
    catch(e){ // retry once
      setTimeout(()=> window.speechSynthesis.speak(u), 120);
    }
  }
  next();
}
function stopSpeaking(){ window.speechSynthesis && window.speechSynthesis.cancel(); speakQueue=[]; speaking=false; $('status').textContent='Stopped'; setTimeout(()=>$('status').textContent='',1200); }

$('testVoiceBtn').onclick = async ()=>{
  savePrefs(); window.speechSynthesis.cancel();
  await new Promise(r=>setTimeout(r,120));
  const u=new SpeechSynthesisUtterance('This is your saved Google narrator voice.');
  const v=currentVoice(); if(v) u.voice=v; u.rate=parseFloat($('rate').value||'1'); u.pitch=parseFloat($('pitch').value||'1');
  window.speechSynthesis.speak(u);
};
$('speakBtn').onclick     = ()=> speakQueueStart();
$('stopBtn').onclick      = ()=> stopSpeaking();
$('voiceSelect').onchange = savePrefs;
$('forceEnglish').onchange= ()=>{ savePrefs(); populateVoices(); };
$('rate').oninput = savePrefs; $('pitch').oninput = savePrefs;

if('speechSynthesis' in window){
  loadPrefs();
  populateVoices();
} else {
  $('status').textContent = 'Speech not supported in this browser';
}

// Ready
Promise.all([fetch(MAP_URL).then(r=>r.json()).catch(()=>null),
             fetch(OV_URL).then(r=>r.json()).catch(()=>({}))])
  .then(([map, ov]) => {
    DB = map || {}; OV = ov || {};
    $('status').textContent = 'Ready ('+VERSION+')';
    setTimeout(()=> $('status').textContent='', 1500);
  });
</script>
</body>
</html>
